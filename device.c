#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <assert.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>

#include "lib_general.h"
#include "device.h"
#include "lib_lnt.h"

#include "gpio_ctrl.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>




#define LNT_WR_HEAD					0xBA
#define LNT_RD_HEAD					0xBD

#define LNT_PROT_RX_LEN				(5)				

#define USING_WR_N				
#define USING_RD				


struct var_data
{
	unsigned int idx;
	unsigned int total_len;
	unsigned char data[1024];
}__attribute__((packed));

struct vla_data
{
	unsigned char cmd;
	unsigned char cla;
	unsigned char ins;
	unsigned char p1;
	unsigned char p2;
	unsigned char leorlc;
}__attribute__((packed));
typedef struct vla_data vla_data_t;

static lib_serial_t g_serial;
static struct var_data g_var_data;

#define VAR_DATA				g_var_data.data
#define VAR_DATA_LEN		g_var_data.total_len

static unsigned char __calc_check_sum(unsigned char *data, const unsigned int len)
{
	int i;
	unsigned char ck = 0;

	for(i = 0; i< len; i++)
	{
		ck = ck ^ data[i];
	}

	return ck;
}

static void __var_data_hd(void)
{
	memset(&g_var_data, 0, sizeof(struct var_data));
	g_var_data.data[0] = LNT_WR_HEAD;
	g_var_data.total_len += 1;
}

static void __var_data_cmd(const unsigned char cmd)
{
	g_var_data.data[2] = cmd;
	g_var_data.idx = 3;
	g_var_data.total_len += 2;
}

static void __var_data_crc(void)
{
	g_var_data.data[1] = g_var_data.idx -1;
	g_var_data.data[g_var_data.idx] = __calc_check_sum(g_var_data.data, g_var_data.total_len);
	g_var_data.total_len += 1;
}

#if 0
static void __var_data_char(const unsigned char ch)
{
	g_var_data.data[g_var_data.idx] = ch;
	g_var_data.idx += 1;
	g_var_data.total_len += 1;
}

static void __var_data_short(const unsigned short sot)
{
	unsigned short m_sot = htons(sot);
	memcpy(&(g_var_data.data[g_var_data.idx]), &m_sot, 2);
	g_var_data.idx += 2;
	g_var_data.total_len += 2;		
}

static void __var_data_int(const unsigned short it)
{
	unsigned int m_it = htonl(it);
	memcpy(&(g_var_data.data[g_var_data.idx]), &m_it, 4);
	g_var_data.idx += 4;
	g_var_data.total_len += 4;		
}
#endif

static void __var_data_set(void *ptr, const unsigned int size)
{
	memcpy(&(g_var_data.data[g_var_data.idx]), ptr, size);
	g_var_data.idx += size;
	g_var_data.total_len += size;
}

static void __var_data_printf(void)
{
	int i;
	
	//fprintf(stderr, "idx: %d\n", g_var_data.idx);
	//fprintf(stderr, "total_len: %d\n", g_var_data.total_len);

	for(i = 0; i < g_var_data.total_len; i++)
	{
		if(i % 16 == 0)
			fprintf(stderr, "\n");
		fprintf(stderr, "%02x ", g_var_data.data[i]);
	}

	fprintf(stderr, "\n");
}

static void __cla_var_data_hd(vla_data_t *vla)
{
	memset(&g_var_data, 0, sizeof(struct var_data));
	g_var_data.data[0] = LNT_WR_HEAD;
	memcpy(&g_var_data.data[2], vla, sizeof(struct vla_data));
	g_var_data.idx = 8;
	g_var_data.total_len += 8;	
}

static void __cla_var_data_set(void *ptr, const unsigned int size)
{
	memcpy(&(g_var_data.data[g_var_data.idx]), ptr, size);
	g_var_data.idx += size;
	g_var_data.total_len += size;	
}

static void __cla_var_data_crc(void)
{
	g_var_data.data[1] = g_var_data.idx -1;
	g_var_data.data[g_var_data.idx] = __calc_check_sum(g_var_data.data, g_var_data.total_len);
	g_var_data.total_len += 1;
}

static void __cla_var_data_printf(void)
{
	int i;
	
	for(i = 0; i < g_var_data.total_len; i++)
	{
		if(i % 16 == 0)
			fprintf(stderr, "\n");
		fprintf(stderr, "%02x ", g_var_data.data[i]);
	}

	fprintf(stderr, "\n");
}

/* ¶Á¿¨Æ÷Éý¼¶×¨ÓÃ add by zjc at 2016-07-22 */
static void __CLA_INS_DATA_HEADER(int stage)
{
	memset(&g_var_data, 0, sizeof(struct var_data));
 	g_var_data.data[0] = LNT_WR_HEAD;  //header
	g_var_data.data[2] = 0xFF;  //command
	g_var_data.data[3] = stage;  //sub command
	
	g_var_data.idx = 4;
	g_var_data.total_len += 4;	
}

static void __CLA_INS_DATA_HD(void)
{
	memset(&g_var_data, 0, sizeof(struct var_data));
 	g_var_data.data[0] = LNT_WR_HEAD;  //header
	g_var_data.data[2] = 0x40;  //command
	
	g_var_data.idx = 3;
	g_var_data.total_len += 3;	
}

static void __CLA_INS_DATA_SET(void *ptr, const unsigned int size)
{
	memcpy(&(g_var_data.data[g_var_data.idx]), ptr, size);
	g_var_data.idx += size;
	g_var_data.total_len += size;	
}

static void __CLA_INS_DATA_CRC(void)
{
	g_var_data.data[1] = g_var_data.idx -1;
	g_var_data.data[g_var_data.idx] = __calc_check_sum(g_var_data.data, g_var_data.total_len);
	g_var_data.total_len += 1;	
}

#if 1
static void __CLA_INS_DATA_PRINTF(void)
{
	int i;
	
	for(i = 0; i < g_var_data.total_len; i++)
	{
		if(i % 16 == 0)
			fprintf(stderr, "\n");
		fprintf(stderr, "%02x ", g_var_data.data[i]);
	}

	fprintf(stderr, "\n");
}
#endif


#if 0
static int __dev_serial_write_lock()
{

	lib_mutex_lock(lib_mutex_t * mutex)

	int n = lib_writen();

	lib_mutex_unlock()

	return n;
}
#endif


int dev_init(char *tty, const unsigned int baudrate)
{
	int err = LIB_GE_ERROR;
	
	strcpy(g_serial.pathname, tty);
	g_serial.flags = O_RDWR;
	g_serial.speed = baudrate;
	g_serial.databits = 8;
	g_serial.stopbits = 1;
	err = lib_serial_init(&g_serial);
	if(err == LIB_GE_ERROR)
	{
		//SYS_LOG_ERR("%s:serial init failed!\n", __FUNCTION__);
		return -1;
	}

	return 0;
}

void dev_release(void)
{
	lib_serial_close(&g_serial);
}




int dev_get_version(lnt_getversion_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN + sizeof(lnt_getversion_ack_t) + 32;
	
	__var_data_hd();
	__var_data_cmd(LNT_GETVERSION);
	__var_data_crc();

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	
	//printf("write ret:%d\n", ret);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		
		//lib_printf_v2("get ver read",rxbuf,ret,16);
		if(ret > 0)
		{	
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_GETVERSION))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_getversion_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;
}

int dev_core_init(lnt_core_init_req_t *req, lnt_core_init_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if((req == NULL) ||(ack == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len= LNT_PROT_RX_LEN + sizeof(lnt_core_init_ack_t);
	
	__var_data_hd();
	__var_data_cmd(LNT_CORE_INIT);
	__var_data_set(req, sizeof(lnt_core_init_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_CORE_INIT))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_core_init_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;
}

int dev_set_parameter(lnt_parameter_set_req_t *req, unsigned char *stat, const unsigned int msec)
{
	if(req == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len= LNT_PROT_RX_LEN;
	
	__var_data_hd();
	__var_data_cmd(LNT_SET_PARAM);
	__var_data_set(req, sizeof(lnt_parameter_set_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_SET_PARAM))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;			

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			return ret;
		}
	}
	
	return LNT_ERROR;;	
}

int dev_qry_ticket_info(lnt_qry_ticket_info_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = sizeof(lnt_qry_ticket_info_ack_t) + LNT_PROT_RX_LEN;
	
	__var_data_hd();
	__var_data_cmd(LNT_QRY_TICKET_INFO);
	__var_data_crc();

	//__var_data_printf();

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_QRY_TICKET_INFO))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_qry_ticket_info_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;	
}

int dev_qry_rent_info(lnt_rent_info_req_t *req, lnt_rent_info_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if((req == NULL) ||(ack == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = sizeof(lnt_rent_info_ack_t) + LNT_PROT_RX_LEN;
		
	__var_data_hd();
	__var_data_cmd(LNT_QRY_RENT_INFO);
	__var_data_set(req, sizeof(lnt_rent_info_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_QRY_RENT_INFO))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_rent_info_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;	
}

int dev_set_rent_info(lnt_rent_info_t *rent, unsigned char *stat, const unsigned int msec)
{
	if(rent == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN;

	rent->rent.app_locker = 0x00;  //0x00:Õý³£, 0x01:Ó¦ÓÃËø¶¨,!!!!!½÷É÷Ð´Èë£¡

	__var_data_hd();
	__var_data_cmd(LNT_SET_RENT_INFO);
	__var_data_set(rent, sizeof(lnt_rent_info_t));
	__var_data_crc();

	//__var_data_printf();

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_SET_RENT_INFO))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;			

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			return ret;
		}
	}

	return LNT_ERROR;		
}

int dev_set_blacklist_flag(lnt_blacklist_record_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN + sizeof(lnt_blacklist_record_ack_t);
	
	__var_data_hd();
	__var_data_cmd(LNT_SET_BL_FLAG);
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_SET_BL_FLAG))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_blacklist_record_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;	
}

int dev_get_history_record(lnt_history_record_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	
	__var_data_hd();
	__var_data_cmd(LNT_GET_HIS_RECORD);
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_GET_HIS_RECORD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_history_record_ack_t));
			
			return ret;
		}
	}
	
	return ret;		
}

int dev_get_trade_record(lnt_trade_record_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = sizeof(lnt_trade_record_ack_t) + LNT_PROT_RX_LEN;
	
	__var_data_hd();
	__var_data_cmd(LNT_GET_TRANS);
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_GET_TRANS))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_trade_record_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;		
}

int dev_consume(lnt_consume_req_t *req, unsigned char *stat, const unsigned int msec)
{
	if(req == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN;
	
	__var_data_hd();
	__var_data_cmd(LNT_CONSUME);
	__var_data_set(req, sizeof(lnt_consume_req_t));
	__var_data_crc();

	//__var_data_printf();

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	//lib_printf("consume write data",VAR_DATA,ret);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		//printf("consume read ret:%d\n",ret);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_CONSUME))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			return ret;
		}
	}

	return LNT_ERROR;	
}




















#if 0
int dev_r_init(lnt_r_init_ack_t *ack, unsigned char *stat, unsigned short *sw, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned short tsw = 0;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;

	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0x10;
	vla.p1 = 0x01;
	vla.p2 = 0x02;
	vla.leorlc = 0x00;

	__cla_var_data_hd(&vla);
	__cla_var_data_crc();
	//__cla_var_data_printf();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			if(sw != NULL)
			{
				memcpy(&tsw, &(rxbuf[ret - 3]), 2);
				*sw = LNT_NTOHS(tsw);
			}
				
			memcpy(ack, &rxbuf[4], rxbuf[1] - 5);

			return ret;		
		}
	}

	return ret;	
}
#endif


int dev_CLA_INS_pkg(void *s_ptr, const unsigned int s_len, void *d_ptr, const unsigned int d_len, unsigned char *d_stat, const unsigned int msec)
{	
	if((s_ptr == NULL) || (d_ptr == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len= LNT_PROT_RX_LEN + d_len; 
		
	__CLA_INS_DATA_HD();
	__CLA_INS_DATA_SET(s_ptr, s_len);
	__CLA_INS_DATA_CRC();
	
	//__CLA_INS_DATA_PRINTF();

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1])  
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(d_stat != NULL)
				*d_stat = rxbuf[3];

			if(d_len < rxbuf[1] - 3)
				return -5; //ÄÚ´æ²»×ã

			memcpy(d_ptr, &rxbuf[4], rxbuf[1] - 3);

			return ret;		
		}
	}
	
	return LNT_ERROR;
}




/* ¶Á¿¨Æ÷Éý¼¶×¨ÓÃ add by zjc at 2016-07-22 */
int dev_CLA_INS_packet(void *s_ptr, const unsigned int s_len, void *d_ptr, const unsigned int d_len, unsigned char *d_stat, unsigned int stage, const unsigned int msec)
{
	if((s_ptr == NULL) || (d_ptr == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[256] = {0};

	if(stage)
		__CLA_INS_DATA_HEADER(stage);
	else
		__CLA_INS_DATA_HD();
	
	__CLA_INS_DATA_SET(s_ptr, s_len);
	__CLA_INS_DATA_CRC();

	unsigned int expect_len = LNT_PROT_RX_LEN + d_len; 
	//__CLA_INS_DATA_PRINTF();

	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	
	//lib_printf_v2("send data",VAR_DATA,ret,16);
	if(ret > 0)
	{	
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD_UPDATE))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(d_stat != NULL)
				*d_stat = rxbuf[3];

			if(d_len < rxbuf[1] - 3)
				return -5; //ÄÚ´æ²»×ã

			memcpy(d_ptr, &rxbuf[4], rxbuf[1] - 3);

			return ret;		
		}
	}
	
	return ret;
}

int dev_r_init(lnt_r_init_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;
	unsigned char rxlen = 0;
	unsigned int expect_len= LNT_PROT_RX_LEN + sizeof(lnt_r_init_ack_t); 
	
	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0x10;
	vla.p1 = 0x01;
	vla.p2 = 0x02;
	vla.leorlc = 0x00;

	__cla_var_data_hd(&vla);
	__cla_var_data_crc();
	//__cla_var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return LNT_ERROR;

			rxlen = ret - 2;
			if(rxlen != rxbuf[1])  
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], rxbuf[1] - 3);

			return ret;		
		}
	}

	return LNT_ERROR;	
}


int dev_r_ac_login_1(lnt_r_ac_login_1_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;

	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0xC8;
	vla.p1 = 0x00;
	vla.p2 = 0x00;
	vla.leorlc = 136;

	__cla_var_data_hd(&vla);
	__cla_var_data_crc();
	__cla_var_data_printf();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], rxbuf[1] - 3);

			return ret;	
		}
	}

	return ret;		
}

int dev_r_ac_login_2(lnt_r_ac_login_2_req_t *req, lnt_r_ac_login_2_ack_t *ack, unsigned char *stat, unsigned short *sw, const unsigned int msec)
{
	if((req == NULL) || (ack == NULL))
		return -1;

	int ret = -1;
	unsigned short tsw = 0;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;

	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0xC9;
	vla.p1 = 0x00;
	vla.p2 = 0x00;
	vla.leorlc = 136;

	__cla_var_data_hd(&vla);
	__cla_var_data_set(req, sizeof(lnt_r_ac_login_2_req_t));
	__cla_var_data_crc();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			if(sw != NULL)
			{
				memcpy(&tsw, &(rxbuf[ret - 3]), 2);
				*sw = LNT_NTOHS(tsw);
			}
				
			memcpy(ack, &rxbuf[4], rxbuf[1] - 5);
			
			return ret;	
		}
	}

	return ret;	
}

int dev_r_pub_qry_his(lnt_r_pub_qry_his_ack_t *ack, unsigned char *stat, unsigned short *sw, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned short tsw = 0;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;

	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0x92;
	vla.p1 = 0x00;
	vla.p2 = 0x00;
	vla.leorlc = 0x00;

	__cla_var_data_hd(&vla);
	__cla_var_data_crc();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			if(sw != NULL)
			{
				memcpy(&tsw, &(rxbuf[ret - 3]), 2);
				*sw = LNT_NTOHS(tsw);
			}
				
			memcpy(ack, &rxbuf[4], rxbuf[1] - 5);
			
			return ret;	
		}
	}

	return ret;	
}

int dev_r_pub_qry_physics_info_NoEncry(lnt_r_pub_qry_physics_info_NoEncry_ack_t *ack, unsigned char *stat, unsigned short *sw, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned short tsw = 0;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;
	unsigned char dataXX;
		
	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0x93;
	vla.p1 = 0x00;   //0x00:²»¼ÓÃÜ
	vla.p2 = 0x00;
	vla.leorlc = 0x00;

	__cla_var_data_hd(&vla);
	__cla_var_data_set(&dataXX, 1);
	__cla_var_data_crc();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			if(sw != NULL)
			{
				memcpy(&tsw, &(rxbuf[ret - 3]), 2);
				*sw = LNT_NTOHS(tsw);
			}
				
			memcpy(ack, &rxbuf[4], rxbuf[1] - 5);
			
			return ret;	
		}
	}

	return ret;		
}

int dev_r_pub_qry_physics_info_Encry(lnt_r_pub_qry_physics_info_Encry_ack_t *ack, unsigned char *stat, unsigned short *sw, const unsigned int msec)
{
	if(ack == NULL)
		return -1;

	int ret = -1;
	unsigned short tsw = 0;
	unsigned char rxbuf[1024] = {0};
	vla_data_t vla;
	unsigned char dataXX;
		
	vla.cmd = LNT_R_CMD;
	vla.cla = LNT_R_CLA;
	vla.ins = 0x93;
	vla.p1 = 0x00;   //0x01:¼ÓÃÜ
	vla.p2 = 0x00;
	vla.leorlc = 0x18; //¼ÓÃÜÊý¾Ý

	__cla_var_data_hd(&vla);
	__cla_var_data_set(&dataXX, 1);
	__cla_var_data_crc();
	
	ret = lib_serial_send(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, sizeof(rxbuf), msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_R_CMD))
				return -1;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return -1;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			if(sw != NULL)
			{
				memcpy(&tsw, &(rxbuf[ret - 3]), 2);
				*sw = LNT_NTOHS(tsw);
			}
				
			memcpy(ack, &rxbuf[4], rxbuf[1] - 5);
			
			return ret;	
		}
	}

	return ret;		
}



















int dev_r_deposit_init(lnt_r_deposit_init_req_t *req, lnt_r_deposit_init_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if((req == NULL) ||(ack == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len= LNT_PROT_RX_LEN + sizeof(lnt_r_deposit_init_ack_t); 
	
	__var_data_hd();
	__var_data_cmd(LNT_DEPOSIT_INIT);
	__var_data_set(req, sizeof(lnt_r_deposit_init_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_DEPOSIT_INIT))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1])  
				return LNT_ERROR;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_r_deposit_init_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;
	
}

int dev_r_deposit_process(lnt_r_deposit_process_req_t *req, lnt_r_deposit_process_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if((req == NULL) ||(ack == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN + sizeof(lnt_r_deposit_process_ack_t); //ÆÚÍû·µ»ØµÄÊý¾Ý³¤¶È
	
	__var_data_hd();
	__var_data_cmd(LNT_DEPOSIT_PROCESS);
	__var_data_set(req, sizeof(lnt_r_deposit_process_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_DEPOSIT_PROCESS))
				return LNT_ERROR;
			
			rxlen = ret - 2;  //Êµ¼Ê·µ»ØµÄÊý¾Ý³¤¶È
			if(rxlen != rxbuf[1])  //ÅÐ¶ÏÁëÄÏÍ¨Ó¦·µ»ØµÄÊý¾Ý³¤¶ÈºÍÊµ¼Ê·µ»ØµÄÊý¾Ý³¤¶ÈÊÇ·ñÒ»ÖÂ
				return LNT_ERROR;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_r_deposit_process_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;	
}

/* 
 * ·¢Íù¶Á¿¨Æ÷µÄAPDUÖ¸Áî	
 */
int dev_apdu_to_reader(lnt_r_apdu_req_t *req, lnt_reader_ack_t *ack, const unsigned int msec)
{
	if(req == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = sizeof(lnt_reader_ack_t);
	
	__var_data_hd();
	__var_data_cmd(LNT_READER_APDU);
	__var_data_set(req, req->len + 1);
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2((char *)__FUNCTION__, (unsigned char *)rxbuf, ret, 16);
		
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_READER_APDU))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1])
				return LNT_ERROR;

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;

			if(ack != NULL)
				memcpy(ack, &rxbuf, rxbuf[1] + 2);
			
			return ret;
		}
	}
	
	return LNT_ERROR;	
}


int dev_qry_admin_card_info(lnt_admin_card_info_req_t *req, lnt_admin_card_info_ack_t *ack, unsigned char *stat, const unsigned int msec)
{
	if((req == NULL) ||(ack == NULL))
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = sizeof(lnt_admin_card_info_ack_t) + LNT_PROT_RX_LEN;
		
	__var_data_hd();
	__var_data_cmd(LNT_QRY_RENT_INFO);
	__var_data_set(req, sizeof(lnt_admin_card_info_req_t));
	__var_data_crc();

	//__var_data_printf();
	
	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_QRY_RENT_INFO))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;
			
			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			memcpy(ack, &rxbuf[4], sizeof(lnt_admin_card_info_ack_t));
			
			return ret;
		}
	}
	
	return LNT_ERROR;		
}

int dev_set_admin_card_info(lnt_admin_card_info_t *admin, unsigned char *stat, const unsigned int msec)
{
	if(admin == NULL)
		return -1;

	int ret = -1;
	unsigned char rxbuf[1024] = {0};
	unsigned char rxlen = 0;
	unsigned int expect_len = LNT_PROT_RX_LEN;
	
	__var_data_hd();
	__var_data_cmd(LNT_SET_RENT_INFO);
	__var_data_set(admin, sizeof(lnt_admin_card_info_t));
	__var_data_crc();

	//__var_data_printf();

	admin->admin_36bytes.A1 = 0x00;  //0x00:Õý³£, 0x01:Ó¦ÓÃËø¶¨,!!!!!½÷É÷Ð´Èë£¡

	ret = lib_writen(g_serial.sfd, VAR_DATA, VAR_DATA_LEN);
	if(ret > 0)
	{
		ret = lib_serial_readn_select(g_serial.sfd, rxbuf, expect_len, msec);
		if(ret > 0)
		{
			//lib_printf_v2(__FUNCTION__, rxbuf, ret, 16);
			
			if((rxbuf[0] != LNT_RD_HEAD) || (rxbuf[2] != LNT_SET_RENT_INFO))
				return LNT_ERROR;

			rxlen = ret - 2;  
			if(rxlen != rxbuf[1]) 
				return LNT_ERROR;			

			if(__calc_check_sum(rxbuf, ret - 1) != rxbuf[ret - 1])
				return LNT_ERROR;
			
			if(stat != NULL)
				*stat = rxbuf[3];

			return ret;
		}
	}

	return LNT_ERROR;		
}


/* ----------------------------------------- ¶Á¿¨Æ÷Éý¼¶ ----------------------------------------- */
#if 1
#define	DEBUG_OUTPUT 0		//µ÷ÊÔÐÅÏ¢Êä³ö

#define	DEV_NAME 		 "/dev/ttyO1" //ÁëÄÏÍ¨¶Á¿¨Æ÷´®¿Ú

#define LIB_UPDATE_OK			1	//Éý¼¶³É¹¦
#define LIB_UPDATE_ERR   		2	//Éý¼¶Ê§°Ü

#define SEND_MSLEEP		40	 //Ã¿·¢ËÍÒ»¸öÊý¾Ý°üµÄÊ±¼ä¼ä¸ô(ms),½¨Òé>=40!

#define	UPDATE_STAT 	0xF1 //Éý¼¶×´Ì¬ÉèÖÃ
#define PRE_UPDATE		0xF2 //Ô¤Éý¼¶			
#define	EXIT_UPDATE		0xF3 //ÍË³öÉý¼¶×´Ì¬

#define	MAX_SIZE		200*1024 //¹Ì¼þ»º³åÇø´óÐ¡
#define	SEND_SIZE		256  	 //Éý¼¶Ê±Ã¿´Î·¢ËÍµÄÊý¾Ý°ü´óÐ¡

unsigned char exit_update[16] = {0xFF,0x4C,0x4E,0x54,0xFF,0x46,0x49,\
	0x52,0x4D,0x57,0x41,0x52,0x45,0xFF,0x00,0xFF}; //ÍË³öÉý¼¶Ä£Ê½
	

static volatile unsigned int update_stat = READER_UPDATE_FAILED;	//¼ÇÂ¼¶Á¿¨Æ÷Éý¼¶×´Ì¬

/*»ñÈ¡¶Á¿¨Æ÷Éý¼¶µÄ×´Ì¬*/
enum UPDATE_STATUS lib_get_update_status(void)
{
	lib_gcc_atmoic_get(&update_stat);
	//printf("-----------reader update status:%d\n", update_stat);
	
	return update_stat;
}

int dev_reader_update(char *firmware_path)
{
		
		int gpio_ctrl_fd = -1;	//gpio
		int ret = -1, rret = -1, i = 0, flag = 0, result = LIB_UPDATE_ERR;
		time_t begin_times, end_times;
		unsigned int consume_time = 0;//Éý¼¶ºÄÊ±
		float update_times = 0, success_times = 0, failed_times = 0, exit_faild = 0;
		//Éý¼¶´ÎÊý		³É¹¦´ÎÊý		Ê§°Ü´ÎÊý		ÍË³öÉý¼¶Ä£Ê½Ê§°Ü´ÎÊý
		
		lib_gcc_atmoic_set(&update_stat,READER_UPDATE_ING);
		
		if(NULL == firmware_path)
		{
			return LIB_UPDATE_ERR;
		}
	
#if SUCCESS_RATE_TEST
	while(1)
#endif
	{  //Ñ­»·½øÐÐ¹Ì¼þÉý¼¶²¢Í³¼ÆÉý¼¶³É¹¦ÂÊ
		
		//¹Ì¼þ×Ö·û´®·Ö¸î,ºóÃæÅÐ¶ÏÉý¼¶ÊÇ·ñ³É¹¦ÓÃ
		char *buf = NULL, *pre_buf = NULL;
		const char *delim = "_";//·Ö¸î·û
	
		char firm_name[128] = {0}, firmware[128] = {0};
		//printf("--------%d, %s\n", strlen(firmware_path), firmware_path);
		memcpy(&firm_name,firmware_path,strlen(firmware_path));
		memcpy(&firmware,firmware_path,strlen(firmware_path));
	
		buf = strtok((char *)&firm_name,delim);
		while(NULL != buf){
			//printf("%s\n",buf);
			pre_buf = buf;//±£´æ·Ö¸î³öµÄ×Ö·û´®,È¡×îºóÒ»¸ö·Ö¸î³öµÄ×Ö·û´®
			buf = strtok(NULL,delim);
		}
	
		flag = 0;//ÍË³öÉý¼¶Ä£Ê½Ê§°Ü±ê¼Ç,³É¹¦Îª1
		update_times++;
		
		time(&begin_times);
		
		//------------¶Á¿¨Æ÷¹Ì¼þÉý¼¶---------------//
		//Éý¼¶Ç°¶ÁÈ¡¹Ì¼þ
		unsigned char rxbuf[128] = {0}, success_recv[5] = {0}, status = -1;
		unsigned int fsize = -1;//²»ÄÜÊÇunsigned short!
		FILE *fp;
		
		fp = fopen(firmware_path,"r");
		if(NULL == fp){
			perror("fopen");
			goto err;
		}
		
#if 0
		fseek(fp, 0L, SEEK_END);  
		fsize = ftell(fp);
#else
		int type;
		struct stat statbuff;
		memset(&statbuff,0,sizeof(statbuff));
		
		if(stat(firmware_path, &statbuff) < 0){  
			goto exit;	
		}else{	
			fsize = statbuff.st_size; //ÎÄ¼þ´óÐ¡
			type = statbuff.st_mode & S_IFREG;//ÎÄ¼þÀàÐÍ
		}
#endif
	
		if(type != S_IFREG){	
		#if DEBUG_OUTPUT
			printf("file format error!\n"); 
		#endif
			goto exit;
		}
	#if DEBUG_OUTPUT
		printf("update firmware:%s\n",firmware);
		printf("file size = %d bytes.\n",fsize);//ÎÄ¼þ×Ü´óÐ¡
	#endif
		unsigned int size = -1, lsize = -1, pre_size = -1, packets = -1;
		unsigned char sbuf[MAX_SIZE] = {0};
	
		rewind(fp);
		size = fread(sbuf,fsize,1,fp);//¶ÁÈ¡Õû¸öÎÄ¼þ	
	#if DEBUG_OUTPUT
		printf("read size = %d bytes.\n",size * fsize); 
	#endif
#if 1	
		//step1:ÍË³öÉý¼¶Ä£Ê½
		for(i = 0; i < 3; i++)//³¢ÊÔ3´Î
		{
			ret = dev_CLA_INS_packet(&exit_update,sizeof(exit_update),&rxbuf,0,&status,EXIT_UPDATE,5000);
			if((ret <= 0) || (status != 0x00))
			{	
		#if DEBUG_OUTPUT
				fprintf(stderr,"exit_update failed! ret = %d, status = %02x\n",ret,status);
		#endif
				lib_sleep(1);
			}
			else{
				flag = 1;//³É¹¦±êÖ¾
				break;
			}
		}
		if((flag == 0) && (i == 3))
		{
			failed_times++;
			exit_faild++;
			goto exit;
		}
		
		//step2:¡¾Éý¼¶×´Ì¬¡¿ÉèÖÃÎªÉý¼¶Ä£Ê½¿ªÆô
		update_stat_set_t set_stat;
		memset(&set_stat,0,sizeof(set_stat));
	
		lsize = fsize - 240;//Ê£ÏÂµÄ×Ö½Ú
		packets = (lsize / 256) + ((lsize % 256)?1:0) + 1;//×ÜÊý¾Ý°üÊý(°üÀ¨Ç°240×Ö½Ú)
#if DEBUG_OUTPUT
		printf("total packets = %d.\n",packets);
#endif
		set_stat.mode = 0x01;//Éý¼¶Ä£Ê½¿ªÆô
		set_stat.total_packets = (unsigned short)packets;
		
		ret = dev_CLA_INS_packet(&set_stat,sizeof(set_stat),&rxbuf,0,&status,UPDATE_STAT,5000);//ÑÓÊ±½¨Òé>=1600
		if((ret <= 0) || (status != 0x00))
		{
	#if DEBUG_OUTPUT
			fprintf(stderr,"update_stat_set start failed! ret = %d, status = 0x%02x\n",ret,status);
	#endif
			failed_times++;
	#if 1
			//Éý¼¶Ê§°ÜºóÍË³öÉý¼¶Ä£Ê½
			for(i = 0; i < 3; i++)//³¢ÊÔ3´Î
			{
				ret = dev_CLA_INS_packet(&exit_update,sizeof(exit_update),&rxbuf,0,&status,EXIT_UPDATE,500);
				if((ret <= 0) || (status != 0x00))
				{
			#if DEBUG_OUTPUT
					fprintf(stderr,"exit_update failed! ret = %d, status = %02x\n",ret,status);
			#endif
					lib_sleep(1);
				}
				else{
					flag = 1;//³É¹¦±êÖ¾
					break;
				}
			}
			if((flag == 0) && (i == 3))
			{
				failed_times++;
				exit_faild++;
				goto exit;
			}
	#endif
			goto exit;
		}
		
		//step3:Ô¤Éý¼¶(·¢ËÍ¹Ì¼þÇ°Ãæ240¸ö×Ö½Ú)
		unsigned int send_size = -1;
		pre_update_ack_t pre_ack;
		memset(&pre_ack,0,sizeof(pre_ack));
		
		ret = dev_CLA_INS_packet(&sbuf,240,&pre_ack,sizeof(pre_ack),&status,PRE_UPDATE,500);
		if((ret <= 0) || (status != 0x00))
		{
	#if DEBUG_OUTPUT
			fprintf(stderr,"pre_update failed! ret = %d, status = 0x%02x\n",ret,status);
	#endif
			failed_times++;
	#if 1
			//Éý¼¶Ê§°ÜºóÍË³öÉý¼¶Ä£Ê½
			for(i = 0; i < 3; i++)//³¢ÊÔ3´Î
			{
				ret = dev_CLA_INS_packet(&exit_update,sizeof(exit_update),&rxbuf,0,&status,EXIT_UPDATE,500);
				if((ret <= 0) || (status != 0x00))
				{
			#if DEBUG_OUTPUT
					fprintf(stderr,"exit_update failed! ret = %d, status = %02x\n",ret,status);
			#endif
					lib_sleep(1);
				}
				else{
					flag = 1;//³É¹¦±êÖ¾
					break;
				}
			}
			if((flag == 0) && (i == 3))
			{
				failed_times++;
				exit_faild++;
				goto exit;
			}
	#endif
			goto exit;
		}
	#if DEBUG_OUTPUT
		lib_printf_v2("pre_update ack",(unsigned char *)&pre_ack,sizeof(pre_ack),16);
	#endif
 #if 1
		//step4:Éý¼¶(·¢ËÍÊ£ÏÂµÄÊý¾Ý°ü)
		unsigned int index, len = 0;
	 
		fseek(fp, pre_ack.next_position, SEEK_SET);//Ìø×ªµ½Ô¤Éý¼¶·µ»ØµÄÖ¸¶¨³¤¶È 
		pre_size = ftell(fp);
		send_size = pre_size;
	#if DEBUG_OUTPUT
		printf("pre_ack, position = %d.\n",send_size);
	#endif
		lsize = fsize - pre_size;//Ô¤Éý¼¶ºóÊ£ÏÂµÄ×Ö½Ú
		packets = (lsize / 256) + ((lsize % 256)?1:0) + 1;//×ÜÊý¾Ý°üÊý
#if DEBUG_OUTPUT
		printf("left size = %d bytes.\n",lsize); 
		printf("total packets = %d.\n",packets);
		
		printf("already send size:%d, file size:%d\n",send_size,fsize);
#endif
#if 1
		while(send_size < fsize){
			for(index = 1; index < packets; index++){
				if(index < packets - 1){
					len = SEND_SIZE;//ÖÐ¼äÃ¿¸öÊý¾Ý°ü´óÐ¡
				}else{
					len = fsize - pre_size - ((index - 1) * SEND_SIZE);//×îºóÒ»¸öÊý¾Ý°ü´óÐ¡
				}
		#if DEBUG_OUTPUT
				printf("---------->index = %d\n",index);
				printf("---------->packet size = %d\n",len);
		#endif
			
				ret = lib_serial_send(g_serial.sfd,&sbuf[send_size],len);
				//ret = lib_serial_writen_select(g_serial.sfd,&sbuf[send_size],len,2000);
		#if DEBUG_OUTPUT
				//printf("			   send size = %d\n",ret);
		#endif
				lib_msleep(SEND_MSLEEP);//·¢ËÍÌ«¿ìµÄ»°Éý¼¶²»ÄÜ³É¹¦!!
				//Ã¿·¢ËÍÍêÒ»¸öÊý¾Ý°üºó¶ÁÈ¡·¢ËÍ×´Ì¬,¶ÁÈ¡¶Á¿¨Æ÷ÏìÓ¦²ÅÄÜÈ·±£Éý¼¶³É¹¦!
				rret = lib_serial_recv(g_serial.sfd,&rxbuf,5);
				//rret = lib_serial_readn_select(g_serial.sfd,&rxbuf,5,2000);
		#if DEBUG_OUTPUT			
				lib_printf_v2("--------recv--------",(unsigned char *)&rxbuf,rret,16);
		#endif			
				if((ret != len) || ((memcmp((char *)&rxbuf, (char *)&success_recv, 5)) != 0))
				{
			#if DEBUG_OUTPUT
					fprintf(stderr,"send packet error! index = %d, packet len:%d, send len:%d\n",index,len,ret);
			#endif
					failed_times++;
	
				#if 1
						//Éý¼¶Ê§°ÜºóÍË³öÉý¼¶Ä£Ê½
						for(i = 0; i < 3; i++)//³¢ÊÔ3´Î
						{
							ret = dev_CLA_INS_packet(&exit_update,sizeof(exit_update),&rxbuf,0,&status,EXIT_UPDATE,500);
							if((ret <= 0) || (status != 0x00))
							{
						#if DEBUG_OUTPUT
								fprintf(stderr,"exit_update failed! ret = %d, status = %02x\n",ret,status);
						#endif
								lib_sleep(1);
							}
							else{
								flag = 1;//³É¹¦±êÖ¾
								break;
							}
						}
						if((flag == 0) && (i == 3))
						{
							failed_times++;
							exit_faild++;
							goto exit;
						}
				#endif
					result = LIB_UPDATE_ERR;
					goto exit;
				}
	
				//ÖÁ´Ë²Å·¢ËÍ³É¹¦
				send_size += ret;	//ÒÑ·¢ËÍÊý¾Ý°ü´óÐ¡
		#if DEBUG_OUTPUT
				printf("already send [%d] bytes.\n\n",send_size);
		#endif
			}
		}
#if DEBUG_OUTPUT
		printf("\nupdate firmware:%s\n",firmware);
		printf("file size = %d bytes.\n",fsize);//ÎÄ¼þ×Ü´óÐ¡
		printf("total packets = %d.\n",packets);
		printf("first packet size = %d.\n",pre_size);
	
		if(send_size == fsize){
			printf("\nsend packet complete!\n");
		}
#endif
#endif
	
		//step5:¡¾Éý¼¶×´Ì¬¡¿ÉèÖÃÎªÉý¼¶Íê³É
		memset(&set_stat,0,sizeof(set_stat));
		set_stat.mode = 0x02;//Éý¼¶Íê³É£¬´ýÐ£ÑéÊý¾Ý
	
		//¶Á¿¨Æ÷²»»áÓÐ»ØÓ¦,µ«±ØÐëÖ´ÐÐÕâÒ»²½
		ret = dev_CLA_INS_packet(&set_stat.mode,sizeof(set_stat.mode),&rxbuf,0,&status,UPDATE_STAT,1000);
	
		lib_sleep(8);//µÈ´ý¶Á¿¨Æ÷ÖØÆô
	
	
		//¶ÁÈ¡¹Ì¼þ°æ±¾²¢¾Ý´ËÅÐ¶ÏÉý¼¶ÊÇ·ñ³É¹¦
#if 1
		//ÁëÄÏÍ¨Ä£¿é´®¿Ú³õÊ¼»¯
		lib_lnt_config_t config;
		memset(&config,0,sizeof(lib_lnt_config_t));
		
		strcpy((char *)config.tty, DEV_NAME);
		config.baudrate = 115200;
		ret = lnt_init(&config);
		if(ret < 0){
		#if DEBUG_OUTPUT
			fprintf(stderr,"lnt_init failed,ret = %d\n",ret);
		#endif
			failed_times++;
			goto exit;
		}
	#if DEBUG_OUTPUT
		fprintf(stderr,"lnt_init success!\n");
	#endif
#endif
		lnt_getversion_ack_t version;
		memset(&version, 0, sizeof(lnt_getversion_ack_t));
		
		dev_get_version(&version,&status,100);
	#if DEBUG_OUTPUT
		fprintf(stderr,"dev_get_version,stat = 0x%02x\n",status);
		fprintf(stderr,"software version:%s\n",version.version); 
	#endif
	
		
		printf("update ver:%s\n",pre_buf);
#if 1
		if(!strncmp((char *)&version,pre_buf,8)){
		#if 1 //DEBUG_OUTPUT
			printf("\n¹§Ï²Äú,¶Á¿¨Æ÷¹Ì¼þÉý¼¶³É¹¦À²!\n");
		#endif
			
			lib_gcc_atmoic_set(&update_stat,READER_UPDATE_SUCCESS);
			
			success_times++;
			result = LIB_UPDATE_OK;
#if SUCCESS_RATE_TEST
			printf("pre_buf len:%d\n",strlen("20160219"));
			if(strncmp(pre_buf, "20160219", strlen("20160219"))){	//¸Ã´ÎÉý¼¶°æ±¾²»ÊÇ20160219
				firmware_path = FIRMWARE;
			}
			else{
				firmware_path = FIRMWARE1;
			}
#endif
		}else{
		#if 1 //DEBUG_OUTPUT
			printf("\n±§Ç¸,¶Á¿¨Æ÷¹Ì¼þÉý¼¶Ê§°ÜÀ²!\n");
		#endif
	
			lib_gcc_atmoic_set(&update_stat,READER_UPDATE_FAILED);
	
			failed_times++;
			result = LIB_UPDATE_ERR;
			#if 0
			gpio_ctrl_fd =  open("/dev/gpio_ctrl", O_RDWR);
			printf("----------gpio_ctrl_fd:%d\n", gpio_ctrl_fd);
			ioctl(gpio_ctrl_fd, GPIO_CTRL_SET_PWR_YCT, GPIO_CTRL_SW_OFF); 	//ÁëÄÏÍ¨¶Á¿¨Æ÷ÉÏµç
			ioctl(gpio_ctrl_fd, GPIO_CTRL_SET_PWR_YCT, GPIO_CTRL_SW_ON); 	//ÁëÄÏÍ¨¶Á¿¨Æ÷ÉÏµç
			#endif
			lnt_init(&config);
		}
#endif
		time(&end_times);
		consume_time = end_times - begin_times;
	#if DEBUG_OUTPUT
		printf("Update takes %d seconds.\n",consume_time);//Éý¼¶ºÄÊ±
	#endif
	
#endif
#endif
	
	exit:
		if(fp != NULL)
			ret = fclose(fp);
		if(ret == EOF){
			perror("fclose");
		}
#if DEBUG_OUTPUT
		printf("\n######################################################################################\n");
		printf("\n\tUpdate times:%.0f, Success times:%.0f, Failed times:%.0f, Take time:%ds.\n",update_times,success_times,failed_times,consume_time);
		printf("\tSuccess percent:%5.2f%%\n",100*success_times/update_times);	
		printf("\n######################################################################################\n");	
#endif
	}//while(1)
	
	err:
		//lib_lnt_release(); //²»ÓÃ!
		//lib_close(gpio_ctrl_fd);
	
		return result;
}
#endif




























